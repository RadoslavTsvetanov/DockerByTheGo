package main

import (
	"fmt"
	"context"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"github.com/google/uuid"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
)

func exposeContainer(containerName string, projectName string) error {
	clientset, err := getK8sClient()
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes client: %v", err)
	}

	// Get the service associated with the container
	service, err := clientset.CoreV1().Services(projectName).Get(context.TODO(), containerName, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get service: %v", err)
	}

	// Check if the service is already of type NodePort
	if service.Spec.Type == corev1.ServiceTypeNodePort {
		fmt.Println("The specified service is already of type NodePort.")
		return nil
	}

	// Find an available NodePort
	nodePort, err := getNodePort()
	if err != nil {
		return err
	}

	// Fetch the old port from the existing service
	if len(service.Spec.Ports) == 0 {
		return fmt.Errorf("service has no ports defined")
	}
	oldPort := service.Spec.Ports[0].Port

	// Update the service to add NodePort
	service.Spec.Type = corev1.ServiceTypeNodePort

	// Update the service ports
	service.Spec.Ports[0] = corev1.ServicePort{
		Port:       oldPort,                      // Keep the existing port
		TargetPort: intstr.FromInt(int(oldPort)), // Update target port
		NodePort:   nodePort,                     // Assign the new NodePort
	}

	// Update the service in Kubernetes
	_, err = clientset.CoreV1().Services(projectName).Update(context.TODO(), service, metav1.UpdateOptions{})
	if err != nil {
		return fmt.Errorf("failed to update service: %v", err)
	}

	fmt.Printf("NodePort %d added successfully to service %s.\n", nodePort, containerName)

	return nil
}

func unxeposeContainer(containerName string, namespace string) error {
	clientset, err := getK8sClient()
	fmt.Print("lool")
	service, err := clientset.CoreV1().Services(namespace).Get(context.TODO(), containerName, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get service: %v", err)
	}

	if service.Spec.Type == corev1.ServiceTypeNodePort {

		// Remove NodePort by changing the service type to ClusterIP or another type
		service.Spec.Type = corev1.ServiceTypeClusterIP
		// Update the servic``
		_, err = clientset.CoreV1().Services(namespace).Update(context.TODO(), service, metav1.UpdateOptions{})
		if err != nil {
			return fmt.Errorf("failed to update service: %v", err)
		}
		fmt.Println("NodePort removed successfully.")
	} else {
		fmt.Println("The specified service is not of type NodePort.")
	}

	return nil
}

func createProject(projectName string, creatorName string) map[string]interface{} {
	createNamespace(projectName)
	adminroleName := "admin" // default admin role
	defaultHandleError(createRole(adminroleName, projectName, adminPolicyRule))
	defaultHandleError(createServiceAccount(creatorName, adminroleName, projectName))
	token, err := getUserToken(projectName, adminroleName)
	defaultHandleError(err)

	return map[string]interface{}{
		"token": token,
	}
}







func CreateUnmanagedContainer(namespace string, name StringOrNil, env map[string]string, labels map[string]string, containerImageName string, port int) {
	switch nameThatForSureIsString := name.(type) {
	case string:
		fmt.Printf("Creating pod %s in namespace %s.\n", nameThatForSureIsString, namespace)
		createPod(namespace, nameThatForSureIsString, "postgres", env, []v1.ContainerPort{
			{
				ContainerPort: int32(port),
			},
		}, labels)

		createService(namespace, nameThatForSureIsString, int32(port), v1.ServiceTypeNodePort, labels)
	case nil:
		fmt.Printf("Creating default pod in namespace %s.\n", namespace)
		autoGeneratedName := uuid.NewString()
		createPod(namespace, autoGeneratedName, "postgres", env, []v1.ContainerPort{
			{
				ContainerPort: int32(port),
			},
		}, labels)

		createService(namespace, autoGeneratedName, int32(port), v1.ServiceTypeNodePort, labels)
	default:
		fmt.Printf("Invalid name type: %T\n", nameThatForSureIsString)
	}
}

func createManagedContainer(namespace string, containerName StringOrNil, env map[string]string, labels map[string]string, imageName string, port int) {

	// Create projectName env variable based on name
	var projectName string
	if strName, ok := containerName.(string); ok {
		projectName = strName
		fmt.Printf("Creating deployment %s in namespace %s.\n", projectName, namespace)
	} else {
		fmt.Printf("Creating default deployment in namespace %s.\n", namespace)
		projectName = uuid.NewString() // Auto-generate name if name is nil
	}
	
	projectSelector := map[string]string{
		"projectname": projectName,
	}

	// Add projectName to env and labels
	labels["projectname"] = projectName

	env["projectName"] = projectName

	// Create deployment and service
	err := CreateDeployment(namespace, projectName, imageName, 1, env, labels)
	defaultHandleError(err)
	createService(namespace, projectName, int32(port), v1.ServiceTypeNodePort, projectSelector)
}







func createNamespace(namespace string) error {
	clientset, err := getK8sClient()
	if err != nil {
		return err
	}

	ns := &v1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: namespace,
		},
	}

	_, err = clientset.CoreV1().Namespaces().Create(context.Background(), ns, metav1.CreateOptions{})
	if err != nil {
		return err
	}
	fmt.Printf("Namespace %s created successfully.\n", namespace)
	return nil
}




func Postgre(namespace string, name string, env map[string]string, labels map[string]string) {
	createManagedContainer(namespace, name, env, labels, "postgres", 5432)
}

func Mysql(namespace string, name string, env map[string]string, labels map[string]string) {
	createManagedContainer(namespace, name, env, labels, "mysql", 3306)
}

func Mongo(namespace string, name string, env map[string]string, labels map[string]string) {
	createManagedContainer(namespace, name, env, labels, "mongo", 0000)
}

func Redis(namespace string, name string, env map[string]string, labels map[string]string) {
	createManagedContainer(namespace, name, env, labels, "redis", 0000)
}

func setUpProject(name string) {
	defaultHandleError(createNamespace(name))
	createRole("admin", "name", []rbacv1.PolicyRule{
		{
			APIGroups: []string{"", "extensions", "apps"},
			Resources: []string{"*"},
			Verbs:     []string{"*"},
		},
		{
			APIGroups: []string{"batch"},
			Resources: []string{"jobs", "cronjobs"},
			Verbs:     []string{"*"},
		},
	})
}

func deleteProject(namespace string) {
	client, err := getK8sClient()
	defaultHandleError(err)
	// Delete the namespace itself
	deleteNamespace(client, namespace)
}

func setUpFluentd(namespace string) {

}
